use std::time::Duration;

fn main() {
    let rt = emit::setup()
        .emit_to(emit_term::stdout())
        // The `min_by_path_filter` takes an iterator of fully-qualified
        // module paths and minimum level pairs. It can be used to tweak
        // the volume of diagnostic data generated by different parts of
        // an application
        .emit_when(emit::level::min_by_path_filter([
            ("filter_by_level::noisy", emit::Level::Warn),
            ("filter_by_level::noisy::essential", emit::Level::Debug),
        ]))
        .init();

    noisy::exec();
    noisy::essential::exec();

    rt.blocking_flush(Duration::from_secs(5));
}

mod noisy {
    // In `filter_by_level::noisy``
    pub fn exec() {
        // This event will be discarded by the filter
        emit::debug!("Preparing to perform some work");

        emit::error!("It failed!");
    }

    pub mod essential {
        // In `filter_by_level::noisy::essential`
        pub fn exec() {
            emit::debug!("Preparing to perform some essential work");

            emit::error!("It failed, essentially!");
        }
    }
}
